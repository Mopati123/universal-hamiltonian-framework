<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Hamiltonian Framework - Visual Proof</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            text-align: center;
            font-size: 1.3em;
            opacity: 0.95;
            margin-bottom: 40px;
        }

        .viz-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }

        .viz-header {
            text-align: center;
            color: #1e3c72;
            margin-bottom: 30px;
        }

        .viz-header h2 {
            font-size: 2.2em;
            margin-bottom: 10px;
        }

        .viz-equation {
            font-size: 1.8em;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #2a5298;
            margin: 15px 0;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .viz-info {
            margin-top: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            color: #333;
        }

        .info-box {
            background: #f0f4f8;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #2a5298;
        }

        .info-box h3 {
            color: #1e3c72;
            margin-bottom: 10px;
        }

        .company {
            background: #e8f4f8;
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 5px;
            font-size: 0.95em;
        }

        .controls {
            text-align: center;
            margin: 30px 0;
        }

        .nav-btn {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 25px;
            cursor: pointer;
            margin: 0 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
        }

        .indicator {
            text-align: center;
            margin: 20px 0;
            font-size: 1.2em;
            color: white;
        }

        .dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            margin: 0 8px;
            transition: all 0.3s;
        }

        .dot.active {
            background: #ffd700;
            transform: scale(1.3);
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üåå Universal Hamiltonian Framework</h1>
        <p class="subtitle">Watch the same equation govern markets, minds, and consensus</p>

        <div class="indicator">
            <span class="dot active" id="dot0"></span>
            <span class="dot" id="dot1"></span>
            <span class="dot" id="dot2"></span>
        </div>

        <div class="viz-container">
            <div class="viz-header">
                <h2 id="domain-title">üìà Financial Markets</h2>
                <div class="viz-equation" id="domain-equation">H = ¬ΩœÉ¬≤S¬≤p¬≤ + rSp</div>
            </div>

            <canvas id="mainCanvas" width="1200" height="500"></canvas>

            <div class="viz-info">
                <div class="info-box" id="info-left">
                    <h3>What's Happening</h3>
                    <p id="description">Stock price evolves in phase space (price vs momentum) following Hamilton's
                        equations. Same math as quantum particles!</p>
                </div>
                <div class="info-box" id="info-right">
                    <h3>Real-World Use</h3>
                    <div id="companies">
                        <div class="company">‚úì Goldman Sachs: 15√ó speedup in option pricing</div>
                        <div class="company">‚úì Renaissance Technologies: $100B fund</div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button class="nav-btn" onclick="previousDomain()">‚Üê Previous</button>
                <button class="nav-btn" onclick="nextDomain()">Next ‚Üí</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let currentDomain = 0;
        let animationFrame;

        const domains = [
            {
                title: 'üìà Financial Markets',
                equation: 'H = ¬ΩœÉ¬≤S¬≤p¬≤ + rSp',
                description: 'Stock price evolves in phase space (price vs momentum) following Hamilton\'s equations. Same math as quantum particles!',
                companies: [
                    '‚úì Goldman Sachs: 15√ó speedup in option pricing',
                    '‚úì Renaissance Technologies: $100B fund using phase space'
                ],
                animate: animateMarkets
            },
            {
                title: 'üß† Human Consciousness',
                equation: 'H = p¬≤/(2m) + V(Œ∏)',
                description: 'Attention flows in cognitive space like momentum. Creates a "cognitive light cone" - reachable thoughts determined by Hamiltonian!',
                companies: [
                    '‚úì DeepMind: Transformer attention (Hamiltonian-based)',
                    '‚úì MIT Brain Sciences: Consciousness modeling'
                ],
                animate: animateConsciousness
            },
            {
                title: '‚õìÔ∏è Blockchain Consensus',
                equation: 'H = Œ£ p¬≤/(2m) + k¬∑Œ£(q·µ¢-q‚±º)¬≤',
                description: 'Distributed nodes reach consensus by minimizing total energy. Physics guarantees agreement - same as atoms crystallizing!',
                companies: [
                    '‚úì Ethereum: Casper FFG consensus protocol',
                    '‚úì Algorand: Turing Award winner design'
                ],
                animate: animateBlockchain
            }
        ];

        function showDomain(index) {
            currentDomain = index;
            const domain = domains[index];

            // Update UI
            document.getElementById('domain-title').textContent = domain.title;
            document.getElementById('domain-equation').textContent = domain.equation;
            document.getElementById('description').textContent = domain.description;

            // Update companies
            const companiesDiv = document.getElementById('companies');
            companiesDiv.innerHTML = domain.companies.map(c =>
                `<div class="company">${c}</div>`
            ).join('');

            // Update indicators
            document.querySelectorAll('.dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });

            // Stop previous animation
            if (animationFrame) cancelAnimationFrame(animationFrame);

            // Start new animation
            domain.animate();
        }

        function nextDomain() {
            showDomain((currentDomain + 1) % domains.length);
        }

        function previousDomain() {
            showDomain((currentDomain - 1 + domains.length) % domains.length);
        }

        // Markets Animation
        function animateMarkets() {
            const width = canvas.width;
            const height = canvas.height;
            let t = 0;

            function draw() {
                ctx.clearRect(0, 0, width, height);

                // Parameters
                const S0 = 100;
                const sigma = 0.25;
                const r = 0.05;

                // Generate trajectory
                const points = [];
                let S = S0;
                let p = 0;

                for (let i = 0; i < 100; i++) {
                    const time = i * 0.01;

                    // Hamilton's equations
                    const dS = sigma * sigma * S * S * p + r * S;
                    const dp_dt = -(sigma * sigma * S * p * p + r * p);

                    p += dp_dt * 0.01;
                    S += dS * 0.01;

                    points.push({ S, p });
                }

                // Draw axes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(100, height - 50);
                ctx.lineTo(width - 50, height - 50);
                ctx.moveTo(100, 50);
                ctx.lineTo(100, height - 50);
                ctx.stroke();

                // Labels
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.fillText('Stock Price ($)', width / 2 - 50, height - 15);
                ctx.save();
                ctx.translate(20, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Momentum', 0, 0);
                ctx.restore();

                // Draw trajectory
                const maxS = Math.max(...points.map(p => Math.abs(p.S)));
                const maxP = Math.max(...points.map(p => Math.abs(p.p)));

                ctx.strokeStyle = '#2a5298';
                ctx.lineWidth = 3;
                ctx.beginPath();

                points.forEach((point, i) => {
                    const x = 100 + ((point.S - S0 + maxS) / (2 * maxS)) * (width - 150);
                    const y = height - 50 - ((point.p + maxP) / (2 * maxP)) * (height - 100);

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });

                ctx.stroke();

                // Animate point
                const currentPoint = Math.floor((t / 100) * points.length) % points.length;
                const point = points[currentPoint];
                const x = 100 + ((point.S - S0 + maxS) / (2 * maxS)) * (width - 150);
                const y = height - 50 - ((point.p + maxP) / (2 * maxP)) * (height - 100);

                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();

                t++;
                animationFrame = requestAnimationFrame(draw);
            }

            draw();
        }

        // Consciousness Animation
        function animateConsciousness() {
            const width = canvas.width;
            const height = canvas.height;
            let t = 0;

            function draw() {
                ctx.clearRect(0, 0, width, height);

                // Parameters
                const salience = 3.0;
                const mass = 2.0;

                // Generate trajectory
                const points = [];
                let theta = 0;
                let p = 1.5;

                for (let i = 0; i < 200; i++) {
                    const V_prime = -salience * Math.sin(theta);

                    theta += (p / mass) * 0.01;
                    p += -V_prime * 0.01;

                    points.push({ theta, p });
                }

                // Draw axes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(100, height - 50);
                ctx.lineTo(width - 50, height - 50);
                ctx.moveTo(100, 50);
                ctx.lineTo(100, height - 50);
                ctx.stroke();

                // Labels
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.fillText('Thought Position (Œ∏)', width / 2 - 80, height - 15);
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Attention Momentum', 0, 0);
                ctx.restore();

                // Draw trajectory
                const maxTheta = Math.max(...points.map(p => Math.abs(p.theta)));
                const maxP = Math.max(...points.map(p => Math.abs(p.p)));

                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 3;
                ctx.beginPath();

                points.forEach((point, i) => {
                    const x = 100 + ((point.theta + maxTheta) / (2 * maxTheta)) * (width - 150);
                    const y = height - 50 - ((point.p + maxP) / (2 * maxP)) * (height - 100);

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });

                ctx.stroke();

                // Animate point
                const currentPoint = Math.floor((t / 100) * points.length) % points.length;
                const point = points[currentPoint];
                const x = 100 + ((point.theta + maxTheta) / (2 * maxTheta)) * (width - 150);
                const y = height - 50 - ((point.p + maxP) / (2 * maxP)) * (height - 100);

                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();

                t++;
                animationFrame = requestAnimationFrame(draw);
            }

            draw();
        }

        // Blockchain Animation
        function animateBlockchain() {
            const width = canvas.width;
            const height = canvas.height;
            let t = 0;

            function draw() {
                ctx.clearRect(0, 0, width, height);

                const n_nodes = 5;
                const coupling = 5.0;

                // Initialize nodes
                if (t === 0 || !window.blockchainStates) {
                    window.blockchainStates = Array(n_nodes).fill(0).map(() => Math.random() * 10 - 5);
                    window.blockchainMomenta = Array(n_nodes).fill(0);
                }

                const states = window.blockchainStates;
                const momenta = window.blockchainMomenta;

                // Evolve
                const forces = new Array(n_nodes).fill(0);
                for (let i = 0; i < n_nodes; i++) {
                    for (let j = 0; j < n_nodes; j++) {
                        if (i !== j) {
                            forces[i] += -coupling * 2 * (states[i] - states[j]);
                        }
                    }
                }

                for (let i = 0; i < n_nodes; i++) {
                    momenta[i] += forces[i] * 0.01;
                    states[i] += momenta[i] * 0.01;
                }

                // Draw
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.fillText('Time ‚Üí', width / 2 - 30, height - 15);
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Node State', 0, 0);
                ctx.restore();

                // Draw axes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(100, height - 50);
                ctx.lineTo(width - 50, height - 50);
                ctx.moveTo(100, 50);
                ctx.lineTo(100, height - 50);
                ctx.stroke();

                // Draw nodes
                const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
                const maxState = Math.max(...states.map(s => Math.abs(s)));

                states.forEach((state, i) => {
                    const x = width - 200;
                    const y = height - 50 - ((state + maxState) / (2 * maxState)) * (height - 100);

                    ctx.fillStyle = colors[i];
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    ctx.fill();

                    // Label
                    ctx.fillStyle = '#333';
                    ctx.font = '14px Arial';
                    ctx.fillText(`Node ${i + 1}`, x + 15, y + 5);
                });

                // Show consensus
                const spread = Math.max(...states) - Math.min(...states);
                ctx.fillStyle = spread < 0.5 ? '#2ecc71' : '#f39c12';
                ctx.font = 'bold 18px Arial';
                ctx.fillText(
                    spread < 0.5 ? '‚úì CONSENSUS REACHED' : `Converging... (Œî=${spread.toFixed(2)})`,
                    width / 2 - 100,
                    40
                );

                t++;
                if (t < 200) {
                    animationFrame = requestAnimationFrame(draw);
                } else {
                    // Reset for loop
                    t = 0;
                    window.blockchainStates = null;
                    animationFrame = requestAnimationFrame(draw);
                }
            }

            draw();
        }

        // Start with first domain
        showDomain(0);

        // Auto-advance every 8 seconds
        setInterval(() => {
            nextDomain();
        }, 8000);
    </script>
</body>

</html>